#!/usr/bin/env python3
"""Keep the 50 most recent unique GPS placemarks from KML files."""

from __future__ import annotations

import argparse
import heapq
import xml.etree.ElementTree as ET
from copy import deepcopy
from datetime import datetime
from pathlib import Path

KML_NS = "http://www.opengis.net/kml/2.2"
GX_NS = "http://www.google.com/kml/ext/2.2"
NS = {"k": KML_NS}


def extract_station_code(document_name: str) -> str:
    """
    Build a 5-char station code from text after first '-' in document name.

    Examples:
    - 452.120-R-0061 -> R0061
    - 452.020-P-24   -> P0024
    """
    if "-" not in document_name:
        raise ValueError(f"Document name missing '-': {document_name!r}")

    after_first_dash = document_name.split("-", 1)[1]
    alnum = "".join(ch for ch in after_first_dash if ch.isalnum())
    if len(alnum) < 2:
        raise ValueError(f"Cannot derive station code from: {document_name!r}")

    first = alnum[0]
    last = alnum[-1]
    middle = alnum[1:-1]
    zeros_needed = 5 - (1 + len(middle) + 1)
    if zeros_needed < 0:
        middle = middle[-3:]
        zeros_needed = 0
    return f"{first}{'0' * zeros_needed}{middle}{last}"


def parse_point_datetime(name_text: str) -> datetime:
    text = name_text.strip()

    # Fast format dispatch avoids exception-driven probing.
    if len(text) >= 8 and text[2] == "/" and text[5] == "/":
        return datetime.strptime(text, "%d/%m/%y %H:%M")
    if len(text) >= 10 and text[4] == "-" and text[7] == "-":
        return datetime.strptime(text, "%Y-%m-%d %H:%M")

    raise ValueError(f"Unrecognized datetime format: {name_text!r}")


def parse_lat_lon(coords_text: str) -> tuple[str, str]:
    parts = [p.strip() for p in coords_text.strip().split(",")]
    if len(parts) < 2:
        raise ValueError(f"Invalid coordinates text: {coords_text!r}")
    return parts[0], parts[1]


def get_text(el: ET.Element | None) -> str:
    return (el.text or "").strip() if el is not None and el.text is not None else ""


def resolve_output_path(input_path: Path, station: str, output_path: Path | None) -> Path:
    default_name = f"last_50_gps_{station}.kml"

    if output_path is None:
        return input_path.parent / default_name

    if output_path.exists() and output_path.is_dir():
        return output_path / default_name

    if output_path.suffix.lower() == ".kml":
        output_path.parent.mkdir(parents=True, exist_ok=True)
        return output_path

    output_path.mkdir(parents=True, exist_ok=True)
    return output_path / default_name


def transform(input_path: Path, output_path: Path | None = None, limit: int = 50) -> Path:
    ET.register_namespace("", KML_NS)
    ET.register_namespace("gx", GX_NS)

    tree = ET.parse(input_path)
    root = tree.getroot()

    document = root.find("k:Document", NS)
    if document is None:
        raise RuntimeError("No <Document> found")

    doc_name_el = document.find("k:name", NS)
    document_name = get_text(doc_name_el)
    if not document_name:
        raise RuntimeError("No document <name> found")

    station = extract_station_code(document_name)

    gps_folder = document.find("k:Folder[@id='GPS points']", NS)
    if gps_folder is None:
        raise RuntimeError("No <Folder id='GPS points'> found")

    folder_name = get_text(gps_folder.find("k:name", NS)) or "GPS points"
    placemarks = gps_folder.findall("k:Placemark", NS)

    records: list[tuple[datetime, tuple[str, str], ET.Element]] = []
    for placemark in placemarks:
        name_el = placemark.find("k:name", NS)
        coords_el = placemark.find(".//k:Point/k:coordinates", NS)
        raw_name = get_text(name_el)
        raw_coords = get_text(coords_el)
        if not raw_name or not raw_coords:
            continue
        dt = parse_point_datetime(raw_name)
        lat_lon = parse_lat_lon(raw_coords)
        records.append((dt, lat_lon, placemark))

    # Adjacent dedupe in source order:
    # duplicate only when both datetime and lat/lon match the previous item.
    deduped: list[tuple[datetime, tuple[str, str], ET.Element]] = []
    prev_key: tuple[datetime, tuple[str, str]] | None = None
    for dt, lat_lon, placemark in records:
        key = (dt, lat_lon)
        if key == prev_key:
            continue
        deduped.append((dt, lat_lon, placemark))
        prev_key = key

    # More efficient than sorting the entire list when only top-N is needed.
    selected = heapq.nlargest(limit, deduped, key=lambda x: x[0])
    output_path = resolve_output_path(input_path, station, output_path)

    out_root = ET.Element(f"{{{KML_NS}}}kml")
    out_doc = ET.SubElement(out_root, f"{{{KML_NS}}}Document")

    out_doc_name = ET.SubElement(out_doc, f"{{{KML_NS}}}name")
    out_doc_name.text = document_name

    out_folder = ET.SubElement(out_doc, f"{{{KML_NS}}}Folder", {"id": "GPS points"})
    out_folder_name = ET.SubElement(out_folder, f"{{{KML_NS}}}name")
    out_folder_name.text = folder_name

    for dt, _lat_lon, placemark in selected:
        cloned = deepcopy(placemark)
        out_name = cloned.find("k:name", NS)
        if out_name is None:
            out_name = ET.SubElement(cloned, f"{{{KML_NS}}}name")
        out_name.text = f"{station} - {dt.strftime('%Y-%m-%d %H:%M')}"
        out_folder.append(cloned)

    ET.indent(out_root, space="    ")
    ET.ElementTree(out_root).write(output_path, encoding="UTF-8", xml_declaration=True)

    print(f"Station code: {station}")
    print(f"Input GPS placemarks: {len(placemarks)}")
    print(f"After adjacent dedupe: {len(deduped)}")
    print(f"Written placemarks: {len(selected)}")
    print(f"Output: {output_path}")

    return output_path


def process_station_directory(
    parent_dir: Path, output_dir: Path | None = None, limit: int = 50
) -> tuple[int, int, list[tuple[Path, str]]]:
    if not parent_dir.is_dir():
        raise RuntimeError(f"Not a directory: {parent_dir}")

    processed = 0
    skipped = 0
    skipped_dirs: list[tuple[Path, str]] = []

    if output_dir is not None:
        output_dir.mkdir(parents=True, exist_ok=True)

    for station_dir in sorted(parent_dir.iterdir()):
        if not station_dir.is_dir():
            continue
        if station_dir.name.startswith("."):
            continue

        input_kml = station_dir / "position.kml"
        if not input_kml.exists():
            skipped += 1
            skipped_dirs.append((station_dir, "missing position.kml"))
            continue

        print(f"\nProcessing {input_kml}")
        try:
            transform(input_kml, output_path=output_dir, limit=limit)
            processed += 1
        except Exception as exc:  # noqa: BLE001
            skipped += 1
            skipped_dirs.append((station_dir, str(exc)))
            print(f"Skipped {input_kml}: {exc}")

    return processed, skipped, skipped_dirs


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Winnow KML to 50 most recent unique GPS points."
    )
    parser.add_argument(
        "input_kml",
        type=Path,
        nargs="?",
        help="Path to input .kml (single-file mode)",
    )
    parser.add_argument(
        "-p",
        "--path",
        type=Path,
        help="Parent directory containing station subdirectories with position.kml",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help="Output path: file or directory (directory is auto-created)",
    )
    parser.add_argument(
        "--limit", type=int, default=50, help="Number of most recent points to keep"
    )
    args = parser.parse_args()

    if args.path:
        if args.input_kml:
            raise SystemExit("Do not pass positional input_kml when using -p.")
        processed, skipped, skipped_dirs = process_station_directory(
            args.path, output_dir=args.output, limit=args.limit
        )
        print(f"\nDone. Processed: {processed}, Skipped: {skipped}")
        if skipped_dirs:
            print("Skipped directories:")
            for skipped_dir, reason in skipped_dirs:
                print(f"- {skipped_dir} ({reason})")
        return

    if not args.input_kml:
        raise SystemExit("Provide input_kml for single-file mode, or use -p for batch mode.")

    transform(args.input_kml, args.output, limit=args.limit)


if __name__ == "__main__":
    main()
